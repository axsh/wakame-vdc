# -*- coding: utf-8 -*-
require 'isono'
require 'ipaddress'

module Dcmgr
  module NodeModules
    class HvaCollector < Isono::NodeModules::Base
      include Isono::NodeModules
      include Dcmgr::Logger

      initialize_hook do
        rpc = RpcChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        rpc.register_endpoint('hva-collector', Isono::Rack.build do
                                use Isono::Rack::DataStore
                                run proc { |req, res|
                                  Thread.current[Models::BaseNew::LOCK_TABLES_KEY] = {}
                                  app.call(req, res)
                                }
                              end)
      end

      terminate_hook do
      end

      def get_instance(instance_id)
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        ret = inst.to_hash
        ret[:image][:backup_object] = inst.image.backup_object.to_hash
        ret[:image][:backup_object][:backup_storage] = inst.image.backup_object.backup_storage.to_hash
        ret[:image][:backup_object][:uri] = inst.image.backup_object.uri

        # merge backup object details to volume.
        ret[:volume].each { |k, v|
          if v[:backup_object_id]
            v[:backup_object] = Models::BackupObject[v[:backup_object_id]].to_hash
          end
        }

        ret
      end

      def update_instance(instance_id, data)
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?
        if data[:state] == :terminated
          finalize_instance(instance_id, data[:terminated_at])
        else
          inst.set(data).save_changes
        end
        # do not respond model object.
        nil
      end

      # set instance state to terminated and clean all associated items.
      def finalize_instance(instance_id, terminated_at)
        inst = Models::Instance[instance_id] || raise("Unknown instancd ID: #{instance_id}")

        logger.info("finalize_instance(#{instance_id}) terminated at=#{terminated_at}")
        # send delete operation to all associated resources:
        #   volume
        inst.volumes_dataset.alives.each { |v|
          logger.debug("Sending delete operation to volume of #{instance_id}: #{v.canonical_uuid} #{v.state}")
          if ![Constants::Volume::STATE_DELETING, Constants::Volume::STATE_DELETED].member?(v.state.to_s)
            v.state = Constants::Volume::STATE_DELETING
            v.save_changes
            db.after_commit do
              if v.local_volume?
                job.submit("local-store-handle.#{v.volume_device.host_node.node_id}",
                           'delete_volume', inst.canonical_uuid, v.canonical_uuid)
              else
                job.submit("sta-handle.#{v.volume_device.storage_node.node_id}",
                           'delete_volume', v.canonical_uuid)
              end
            end
          end
        }

        # update instance fields here because this method can be
        # called multiple times from agents at the event of failure.
        unless inst.state == Constants::Instance::STATE_TERMINATED
          inst.terminated_at = terminated_at
          inst.destroy
        end
        nil
      end

      def update_image(image_id, data)
        img = Models::Image[image_id] || raise("Unknown image ID: #{image_id}")
        if data[:state] == :deleted
          img.deleted_at = data[:deleted_at]
          img.destroy
        else
          img.set(data).save
        end
        # do not respond model object.
        nil
      end

      def get_network(network_id)
        network = Models::Network[network_id]
        raise "UnknownNetworkID" if network.nil?
        network.to_hash
      end

      def get_nic(nic_uuid)
        nic = Models::Taggable.find(nic_uuid)
        raise "UnknownNIC" if nic.nil?
        nic.to_hash
      end

      def get_networks
        networks = Models::Network.all
        networks.map { |network|
          network.to_hash
        }
      end

      def get_host_nodes_index
        host_nodes = Models::HostNode.all
        host_nodes.map { |host_node| host_node.canonical_uuid }
      end

      def get_host_node(host_node_uuid)
        host_node = Models::HostNode[host_node_uuid]
        raise "UnknownHostNodeID" if host_node.nil?
        host_node.to_api_document
      end

      def prepare_host_node_vnet(host_node_uuid, network_uuid)
        host_node = Models::HostNode[host_node_uuid]
        raise "UnknownHostNodeID" if host_node.nil?
        vnet = host_node.vnet.find { |vnet| vnet.network.canonical_uuid == network_uuid }

        if vnet.nil?
          network = Models::Network[network_uuid]
          raise "UnknownNetworkID" if network.nil?

          vnet = host_node.add_vnet(network)
        end

        vnet.to_api_document
      end

      def get_dhcp_conf(network_name)
        build_network_segment = proc { |network|
          nwaddr = network.ipv4_ipaddress
          h = {
            :uuid => network.canonical_uuid,
            :ipv4_first => nwaddr.first.to_s,
            :ipv4_last  => nwaddr.last.to_s,
            :ipv4_gw=> network.ipv4_gw,
            :netmask => nwaddr.prefix.to_ip,
            :prefix => network.prefix,
            :dns_server=> network.dns_server,
            :domain_name => network.domain_name,
            :metadata_server => network.metadata_server,
            :mac2addr => [],
            :addr2host=> [],
          }

          network.network_vif_ip_lease_dataset.filter(:alloc_type=>Models::NetworkVifIpLease::TYPE_AUTO).alives.each { |ip|
            # ignore IPs unbound to vnic.
            next if ip.network_vif.nil? || ip.network_vif.instance.nil?

            h[:mac2addr] << {
              :mac_addr => ip.network_vif.pretty_mac_addr,
              :ipaddr   => ip.ipv4
            }
            h[:addr2host] << {
              :hostname => ip.network_vif.fqdn_hostname,
              :ipaddr   => ip.network_vif.nat_network_id.nil? ? ip.ipv4 : ip.nat_outside_lease.ipv4
            }
          }

          h
        }

        network_set = nil
        Tags::NetworkGroup
        Models::Network
        case network = Models::Taggable.find(network_name)
        when Models::Network
          network_set = [network]
        when Tags::NetworkGroup
          network_set = network.mapped_uuids.map {|m| Models::Network[m.uuid] }
        else
          raise "Unknown network name: #{network_name}"
        end

        h = {}
        network_set.each {|n|
          h[n.canonical_uuid] = build_network_segment.call(n)
        }
        h
      end

      def get_instance_monitor_data(node_id)
        hp = Models::HostNode.find(:node_id => node_id)
        raise "Unknown host node with node ID: #{node_id}" if hp.nil?

        hp.instances_dataset.filter(:state=>[Const::Instance::STATE_RUNNING, Const::Instance::STATE_HALTING, Const::Instance::STATE_SHUTTING_DOWN]).all.map { |inst|
          {
          :uuid => inst.canonical_uuid,
          :hypervisor => hp.hypervisor,
          :status => inst.status,
          :state => inst.state
          }
        }
      end

      def get_security_groups_of_vnic(vnic_uuid)
        vnic = Models::NetworkVif[vnic_uuid]
        raise "Unknown vnic ID: #{vnic_uuid}" if vnic.nil?

        group_maps = vnic.security_groups_dataset.map { |group|
          group.to_hash
        }
        # }.flatten.uniq.compact
        group_maps
      end

      # Methods for netfilter
      def get_referencers_of_security_group(group_id)
        ref_hash = {}
        Models::SecurityGroup[group_id].referencers.each { |ref|
          ref_id = ref.canonical_uuid
          ref_hash[ref_id] = {}
          ref.network_vif.each {|vnic|
            ref_hash[ref_id][vnic.canonical_uuid] = vnic.to_netfilter_document
          }
        }

        ref_hash
      end

      def get_rules_of_security_group(group_id)
        secg_map = Models::SecurityGroup[group_id].to_hash

        secg_map[:rules]
      end

      def get_referencees_of_security_group(group_id)
        ref_hash = {}
        Models::SecurityGroup[group_id].referencees.each { |ref|
          ref_id = ref.canonical_uuid
          ref_hash[ref_id] = {}
          ref.network_vif.each { |vnic|
            ref_hash[ref_id][vnic.canonical_uuid] = vnic.to_netfilter_document
          }
        }

        ref_hash
      end

      def get_netfilter_security_group(group_id,node_id)
        sg = Models::SecurityGroup[group_id]
        sg.nil? ? nil : sg.to_netfilter_document(node_id)
      end

      def get_netfilter_vnic(vnic_id)
        vif = Models::NetworkVif[vnic_id]
        vif.nil? ? nil : vif.to_netfilter_document
      end

      def get_netfilter_vnic_with_node_id(vnic_id)
        vnic = Models::NetworkVif[vnic_id]

        return nil if vnic.nil?
        {
          :vnic => vnic.to_netfilter_document,
          :node_id => vnic.instance.host_node.node_id
        }
      end

      def get_netfilter_network(network_id)
        network = Models::Network[network_id]
        network.nil? ? nil : network.to_netfilter_document
      end

      # Method designed to get all data needed for the netfilter service in a single request
      def get_netfilter_data(node_id)
        local_vnics_dataset = Models::NetworkVif.filter(:instance => Models::Instance.runnings.filter(:host_node => Models::HostNode.filter(:node_id => node_id)))
        # only lists network assigned VIFs.
        local_vnic_maps  = local_vnics_dataset.filter('network_id IS NOT NULL').all.map {|vnic| vnic.to_netfilter_document }

        # Hash of vnics with no security groups.
        empty_vnics = {}
        security_groups = {}
        networks = {}

        local_vnic_maps.each { |vnic_map|
          if vnic_map[:security_groups].empty?
            # Save vnics without security groups
            empty_vnics[vnic_map[:uuid]] = vnic_map
          else
            vnic_map[:security_groups].each { |group_id|
              if security_groups[group_id] == nil
                secg = Models::SecurityGroup[group_id]
                # Save the security group
                security_groups[group_id] = secg.to_netfilter_document(node_id)
              end
            }
          end

          # Save the network data
          if networks[vnic_map[:network_id]].nil?
            network = Models::Network[vnic_map[:network_id]]
            networks[vnic_map[:network_id]] = network.to_netfilter_document
          end
        }

        {
          :empty_vnics => empty_vnics,
          :security_groups => security_groups,
          :networks => networks
        }
      end

      def get_resource_monitor_data(node_id)
        hp = Models::HostNode.find(:node_id => node_id)
        raise "Unknown host node with node ID: #{node_id}" if hp.nil?

        hp.instances_dataset.filter(:state=>[Const::Instance::STATE_STARTING, Const::Instance::STATE_RUNNING, Const::Instance::STATE_HALTING, Const::Instance::STATE_SHUTTING_DOWN]).all.map {|inst|
          h = {
            :uuid => inst.canonical_uuid,
            :status => inst.status,
            :state => inst.state,
            :vif =>[]
          }
          inst.instance_nic.each { |vif|
            direct_lease_ds = vif.direct_ip_lease_dataset

            network = vif.network
            ent = {
              :vif_id => vif.canonical_uuid,
              :network_id => network.nil? ? nil : network.canonical_uuid,
            }

            direct_lease = direct_lease_ds.first
            if direct_lease.nil?
            else
              outside_lease = direct_lease.nat_outside_lease
              ent[:ipv4] = {
                :address=> direct_lease.ipv4,
                :nat_address => outside_lease.nil? ? nil : outside_lease.ipv4,
              }
            end
            h[:vif] << ent
          }
          h
        }
      end

      def get_resource_monitor_ids(node_id)
        resources = get_resource_monitor_data(node_id)
        resources.map { |r|
          r[:uuid]
        }
      end

      private
      def db
        Sequel::DATABASES.first
      end

      def job
        @job ||= Isono::NodeModules::JobChannel.new(node)
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end
    end
  end
end
