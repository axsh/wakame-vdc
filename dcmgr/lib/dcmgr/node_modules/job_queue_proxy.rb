# -*- coding: utf-8 -*-
require 'isono'

module Dcmgr
  module NodeModules
    # AMQP RPC to self RDBMS based Job Queue proxy.
    class JobQueueProxy < Isono::NodeModules::Base
      include Isono::NodeModules
      include Dcmgr::Logger

      initialize_hook do
        rpc = RpcChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        rpc.register_endpoint('jobqueue-proxy', Isono::Rack.build do
                                use Isono::Rack::DataStore
                                run proc { |req, res|
                                  Thread.current[Models::BaseNew::LOCK_TABLES_KEY] = {}
                                  app.call(req, res)
                                }
                              end)
      end

      terminate_hook do
      end

      def submit(queue_name, resource_uuid, params, opts)
        res = Models::QueuedJob.submit(queue_name, resource_uuid, params, (opts || {}))

        res.to_hash
      end

      def pop(queue_name, worker_id, opts)
        res = Models::QueuedJob.pop(queue_name, worker_id, opts)
        res ? res.to_hash : nil
      end
      
      def cancel(job_id)
        res = Models::QueuedJob.cancel(job_id)
        res.to_hash
      end

      def find(job_id)
        find_job(job_id).to_hash
      end

      def finish_success(job_id, finish_message=nil)
        find_job(job_id).tap { |job|
          job.finish_success(finish_message)
        }.to_hash
      end

      def finish_fail(job_id, failure_reason)
        find_job(job_id).tap { |job|
          job.finish_fail(failure_reason)
        }.to_hash
      end

      private
      def find_job(job_id)
        job = Models::QueuedJob[job_id]
        raise "Unknown Job: #{job_id}" if job.nil?
        job
      end
    end
  end
end
