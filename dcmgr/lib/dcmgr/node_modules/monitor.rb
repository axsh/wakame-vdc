# -*- coding: utf-8 -*-
require 'metric_libs'

module Dcmgr
  module NodeModules
    class Monitor < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers
      include Dcmgr::Monitor
      include MetricLibs::Constants::Alarm

      initialize_hook do
        @alarm_manager = MetricLibs::AlarmManager.new
        @resource_capture = ResourceCapture.new(node)
        rpc = Isono::NodeModules::RpcChannel.new(node)

        EM.defer do
          myinstance.initialize_alarm_from_database
        end

        logger.info("Resource monitor start")
        Dcmgr.conf.capture.config.select {|k, v| k =~ /_time/}.each {|k, v|
          EM.add_periodic_timer(v) do
            EM.defer do
              resources = @resource_capture.get_resources(k.to_s.split("_")[0])
              resources.each {|resource_id, metrics|
                rpc.request('resource-collector', 'resource_store', resource_id, metrics) do |req|
                  req.oneshot = true
                end
                metrics.keys.each {|metric_name|
                  alarms = @alarm_manager.find_alarm(resource_id, metric_name)
                  next if alarms.empty?
                  alarms.each {|alarm|
                    next unless alarm.enabled?
                    logger.info("Update resource: #{alarm.uuid} #{metrics}")
                    alarm.feed(metrics)
                    if alarm.evaluate?
                      logger.info("Evaluation Alarm: #{alarm.uuid} #{alarm.metric_name}")
                      evaluated = alarm.evaluate
                      if alarm.changed_state?
                        action = evaluated["#{evaluated["state"]}_actions"]
                        message = Notification.build_message(action, evaluated.merge({"ipaddr" => metrics["ipaddr"]}))
                        logger.info("Send Notification #{action["notification_id"]}")
                        Notification.send(message)
                      end
                      rpc.request('alarm-collector', 'update_alarm', evaluated["uuid"], evaluated) do |req|
                        req.oneshot = true
                      end
                    end
                    
                  }
                }
              }
            end
          end
        }

        job = Isono::NodeModules::JobChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        job.register_endpoint("resource-alarm-registry.#{node.node_id}",
          Isono::Rack.build do
            run proc {|req, res|
              app.call(req, res)
            }
          end)
      end

      terminate_hook do
      end

      def update_alarm(alarm_id)
        alm = get_alarm(alarm_id)
        logger.info("Update alarm: #{alm[:uuid]}")
        EM.next_tick do
          @alarm_manager.update(merge_capture_periods(alm).first)
        end
      end

      def update_alarms(alarm_ids)
        alms = get_alarms(alarm_ids)
        logger.info("Update alarms: #{alarm_ids}")
        EM.next_tick do
          @alarm_manager.updates(merge_capture_periods(alms))
        end
      end

      def delete_alarm(alarm_id)
        alm = get_alarm(alarm_id)
        logger.info("Remove alarm: #{alm[:uuid]}")
        EM.next_tick do
          @alarm_manager.delete(alm)
        end
      end

      def delete_alarms(alarm_ids)
        alms = get_alarms(alarm_ids)
        logger.info("Remove alarms: #{alarm_ids}")
        EM.next_tick do
          @alarm_manager.deletes(alms)
        end
      end

      def get_alarm(alm_id)
        raise ArgumentError unless alm_id.is_a?(String)
        rpc.request('alarm-collector', 'get_alarm', alm_id)
      end

      def get_alarms(alm_ids)
        raise ArgumentError unless alm_ids.is_a?(Array)
        rpc.request('alarm-collector', 'get_alarms', alm_ids)
      end

      def initialize_alarm_from_database
        logger.info("Initialize alarm from database")
        # TODO: add volume and network vif
        resource_ids = rpc.request('hva-collector', 'get_resource_monitor_ids', node.node_id)
        return if resource_ids.blank?
        alarms = rpc.request('alarm-collector', 'get_resource_alarms', resource_ids)

        logger.info("Update alarms: #{alarms}")
        @alarm_manager.updates(merge_capture_periods(alarms))
      end

      private
      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def merge_capture_periods(alms)
        alms = [alms] if alms.is_a?(Hash)
        alms.map {|alm|
          alm.merge({:capture_periods =>Dcmgr.conf.capture.config["#{alm[:metric_name].split('.')[0]}_time".to_sym]})
        }
      end

    end

  end
end
