# -*- coding: utf-8 -*-
require 'metric_libs'

module Dcmgr
  module NodeModules
    class Monitor < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers
      include Dcmgr::Monitor
      include MetricLibs::Constants::Alarm

      initialize_hook do
        @alarm_manager = MetricLibs::AlarmManager.new
        @resource_capture = ResourceCapture.new(node)
        rpc = Isono::NodeModules::RpcChannel.new(node)

        EM.defer do
          myinstance.initialize_alarm_from_database
        end

        logger.info("Resource monitor start")
        Dcmgr.conf.capture.config.select {|k, v| k =~ /_time/}.each {|k, v|
          EM.add_periodic_timer(v) do
            EM.defer do
              resources = @resource_capture.get_resources(k.to_s.split("_")[0])
              resources.each {|k, v|
                rpc.request('resource-collector', 'resource_store', k, v) do |req|
                  req.oneshot = true
                end
                alarm = @alarm_manager.find_alarm(k, v)
                next if alarm.nil? || !alarm.enabled?
                logger.info("Update resource: #{alarm.uuid} #{v}")
                alarm.feed(v)
                if alarm.evaluate?
                  logger.info("Evaluation Alarm: #{alarm.uuid} #{alarm.metric_name}")
                  evaluated = alarm.evaluate
                  if alarm.changed_state?
                    action = evaluated[evaluated["state"].gsub(/state/, "actions")]
                    message = Notification.build_message(action, evaluated.merge({"ipaddr" => v["ipaddr"]}))
                    logger.info("Send Notification #{action["notification_id"]}")
                    Notification.send(message)
                  end
                  rpc.request('alarm-collector', 'update_alarm', evaluated["uuid"], evaluated) do |req|
                    req.oneshot = true
                  end
                end
              }
            end
          end
        }

        job = Isono::NodeModules::JobChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        job.register_endpoint("resource-alarm-registry.#{node.node_id}",
          Isono::Rack.build do
            run proc {|req, res|
              app.call(req, res)
            }
          end)
      end

      terminate_hook do
      end

      def update_alarm(alarm_id)
        alm = get_alarm(alarm_id)
        logger.info("Update alarm: #{alm[:uuid]}")
        EM.next_tick do
          @alarm_manager.update(merge_capture_periods(alm).first)
        end
      end

      def delete_alarm(alarm_id)
        alm = get_alarm(alarm_id)
        logger.info("Remove alarm: #{alm[:uuid]}")
        EM.next_tick do
          @alarm_manager.delete(alm)
        end
      end

      def get_alarm(alm_id)
        raise ArgumentError unless alm_id.is_a?(String)
        rpc.request('alarm-collector', 'get_alarm', alm_id)
      end

      def initialize_alarm_from_database
        logger.info("Initialize alarm from database")
        # TODO: add volume and network vif
        instance_ids = rpc.request('hva-collector', 'get_metric_monitor_instance_ids', node.node_id)
        alarms = rpc.request('alarm-collector', 'get_resource_alarms', instance_ids)
        logger.info("Update alarms: #{alarms}")
        @alarm_manager.updates(merge_capture_periods(alarms))
      end

      private
      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def merge_capture_periods(alms)
        alms = [alms] if alms.is_a?(Hash)
        alms.map {|alm|
          alm.merge({:capture_periods =>Dcmgr.conf.capture.config["#{alm[:metric_name].split('.')[0]}_time".to_sym]})
        }
      end

    end

  end
end
