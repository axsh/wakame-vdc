# -*- coding: utf-8 -*-

module Dcmgr
  module NodeModules
    class JobQueueWorker < Isono::NodeModules::Base
      include Dcmgr::Logger
      
      config_section do |c|
        desc "default job concurrency"
        c.concurrency = 1
      end

      initialize_hook do
        @worker_thread = Isono::ThreadPool.new(4)
        @max_attempts = 3
        @pollers = {}
      end

      attr_reader :worker_thread, :max_attempts

      def subscribe(queue_name, concurrency, default_retry_max, job_blk=nil, fail_blk=nil, &blk)
        if @pollers.has_key?(queue_name)
          raise ArgumentError, "#{queue_name} is subscribed already"
        end

        if job_blk.nil?
          if blk.nil?
            raise ArgumentError, "Missing main block argument."
          else
            job_blk = blk
          end
        end
        
        poller = @pollers[queue_name] = Poller.new(queue_name, concurrency, self, default_retry_max, job_blk, fail_blk)
        # trigger initial polling.
        poller.start
      end

      def unsubscribe(queue_name)
        poller = @pollers.delete(queue_name)
        if poller
          poller.stop
        end
      end

      class Poller
        include Dcmgr::Logger

        class PollScheduler
          def initialize(poller, polling_wait_sec)
            raise ArgumentError if !poller.is_a?(Poller)
            @poller = poller

            @polling_wait_sec = polling_wait_sec

            # handled in EM thread.
            @inflight_timers = []
          end

          def start
          end

          def stop
            EM.schedule {
              @inflight_timers.each(&:cancel)
            }
          end

          def wait
            EM.schedule {
              t = EM::Timer.new(@polling_wait_sec) {
                begin
                  @poller.poll
                ensure
                  @inflight_timers.delete(t)
                end
              }
              @inflight_timers << t
            }
          end
        end

        class JobContext
          def initialize(poller, job_hash)
            @subject = poller
            @job_hash = job_hash
          end

          def retry_max
            @job_hash[:retry_max].to_i
          end

          def retry?
            @job_hash[:retry_count] < self.retry_max
          end

          def [](key)
            @job_hash[key]
          end

          def finish_message=(hash)
            @job_hash[:finish_message] = hash
          end

          def finish_message(hash=nil)
            if hash
              self.finish_message = hash
            end
            @job_hash[:finish_message]
          end
        end

        attr_reader :queue_name, :concurrency
        attr_accessor :poll_scheduler
        
        def initialize(queue_name, concurrency, worker, default_retry_max, blk, fail_blk)
          raise ArgumentError if !worker.is_a?(JobQueueWorker)
          @queue_name = queue_name
          @concurrency = concurrency
          @worker = worker
          @block = blk
          @failure_block = fail_blk
          @running = true
          @default_retry_max = default_retry_max

          @poll_scheduler = PollScheduler.new(self, 15)
        end

        def start
          @poll_scheduler.start
          @concurrency.times {
            poll
          }
        end

        def stop
          @running = false
          @poll_scheduler.stop
        end

        def running?
          @running
        end
        
        def poll
          @worker.worker_thread.pass do
            begin
              r = pop_once
            rescue ::Exception => e
              logger.error("Rescheduling queue pop after ?? seconds. Something went wrong.: #{e.message}")
              logger.error(e.backtrace[0, 10].join("\n"))
            ensure
              r ? schedule_immediate :  schedule_next
            end
          end
        end
        
        private

        def pop_once
          job = pop_job
          if job.nil?
            #logger.debug("Rescheduling queue pop after ?? seconds. None of pending jobs found.")
          else
            begin
              run(job)
              Dcmgr::Messaging.job_queue.finish_success(job[:uuid], job[:finish_message])
              logger.info("Finished Job successfully: #{job[:uuid]}")
            rescue ::Exception => e
              if job[:retry_count] < job[:retry_max]
                logger.info("Running Job Failed. Re-queueing. (retry current #{job[:retry_count]} < max #{job[:retry_max]}) : #{job[:uuid]}: #{e.message}")
              else
                logger.info("Running Job Failed. Giving up. (retried #{job[:retry_max]} times): #{job[:uuid]}: #{e.message}")
              end
              Dcmgr::Messaging.job_queue.finish_fail(job[:uuid], e.message)
              raise
            else
              return true
            end
          end
          return false
        end
        
        def pop_job
          attempts = 0
          job = nil
          begin
            job = Dcmgr::Messaging.job_queue.pop(@queue_name, @worker.node.node_id, {:retry_max_if_zero=>@default_retry_max.to_i})
            if job
              logger.info("Found Job from #{@queue_name}: #{job[:uuid]}")
            else
              #logger.debug("None of pending jobs found from #{@queue_name}.")
            end
          rescue => e
            attempts += 1
            if attempts <= @worker.max_attempts
              sleep_sec = (attempts ** 2).to_f
              logger.error("Failed to pop queue from #{@queue_name}. Going to retry after #{sleep_sec} sec. [#{attempts} (current) <= #{@worker.max_attempts} (max)]")
              sleep(sleep_sec)
              if @running
                retry
              else
                return nil
              end
            else
              logger.error("Give up to pop queue exceeds max_attemps retry count. #{@worker.max_attempts}")
            end
          end
          job
        end
        
        def run(job)
          logger.info("Starting Job: #{job[:uuid]}")
          begin
            ctx = Thread.current[:job]=JobContext.new(self, job)
            @block.arity > 0 ? @block.call(ctx) : @block.call
          rescue ::Exception => e
            unless ctx.retry?
              if @failure_block.is_a?(Proc)
                @failure_block.arity > 0 ? @failure_block.call(ctx) : @failure_block.call
              end
            end
            raise e
          ensure
            Thread.current[:job]=nil
          end
        end
        
        def schedule_next
          return if @running == false

          @poll_scheduler.wait
        end

        def schedule_immediate
          return if @running == false
          
          EM.schedule { poll }
        end

      end
    end
  end
end
