# -*- coding: utf-8 -*-
require 'isono'

module Dcmgr
  module NodeModules
    class AlarmCollector < Isono::NodeModules::Base
      include Dcmgr::Logger

      initialize_hook do
        app = Isono::Rack::ObjectMethod.new(myinstance)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        rpc.register_endpoint('alarm-collector', Isono::Rack.build do
                                use Isono::Rack::DataStore
                                run proc { |req, res|
                                  Thread.current[Models::BaseNew::LOCK_TABLES_KEY] = {}
                                  app.call(req, res)
                                }
                              end)

        @worker_thread = Isono::ThreadPool.new(1, 'AlarmCollector')
        event = Isono::NodeModules::EventChannel.new(node)
        event.subscribe('hva/instance_terminated', '#', "#{node.node_id}-resource-alarm") do |args|
          logger.info("event_caught: #{args.inspect}")
          instance_id = args[0]
          @worker_thread.pass {
            Sequel::DATABASES.first.transaction do
              resource = Models::Instance[instance_id]
              raise "UnknownResourceID" if resource.nil?

              conditions = {:metric_name =>Dcmgr::Constants::Alarm::RESOURCE_METRICS, :resource_id =>[resource.canonical_uuid]}
              alarms = Models::Alarm.filter(conditions).alives.all.map {|alarm|
                alarm.canonical_uuid if alarm.destroy
              }
              Dcmgr.messaging.submit("resource-alarm-registry.#{resource.host_node.node_id}", 'delete_alarms', alarms)
            end
          }
        end

        event.subscribe('hva/instance_terminated', '#', "#{node.node_id}-log-alarm") do |args|
          logger.info("event_caught: #{args.inspect}")
          instance_id = args[0]
          @worker_thread.pass {
            Sequel::DATABASES.first.transaction do
              resource = Models::Instance[instance_id]
              raise "UnknownResourceID" if resource.nil?

              conditions = {:metric_name =>Dcmgr::Constants::Alarm::LOG_METRICS, :resource_id =>[resource.canonical_uuid]}
              alarms = Models::Alarm.filter(conditions).alives.all.map {|alarm|
                alarm.canonical_uuid if alarm.destroy
              }
              Dcmgr.messaging.submit("log-alarm-registry.#{resource.host_node.node_id}", 'delete_alarms')
            end
          }
        end

        event.subscribe('hva/instance_turnedoff', '#', "#{node.node_id}-resource-alarm") do |args|
          logger.info("event_caught: #{args.inspect}")
          instance_id = args[0]
          @worker_thread.pass {
            Sequel::DATABASES.first.transaction do
              resource = Models::Instance[instance_id]
              raise "UnknownResourceID" if resource.nil?

              conditions = {:metric_name =>Dcmgr::Constants::Alarm::RESOURCE_METRICS, :resource_id =>[resource.canonical_uuid]}
              
              data = {:state => "init", :state_timestamp => Time.now}

              alarms = Models::Alarm.filter(conditions).alives.all.map {|alarm|
                alarm.canonical_uuid if alarm.set(data).save
              }
              Dcmgr.messaging.submit("resource-alarm-registry.#{resource.host_node.node_id}", 'delete_alarms', alarms)
            end
          }
        end

        event.subscribe('hva/instance_started', '#', "#{node.node_id}-resource-alarm") do |args|
          logger.info("event_caught: #{args.inspect}")
          instance_id = args[0]
          @worker_thread.pass {
              resource = Models::Instance[instance_id]
              raise "UnknownResourceID" if resource.nil?

              conditions = {:metric_name =>Dcmgr::Constants::Alarm::RESOURCE_METRICS, :resource_id =>[resource.canonical_uuid]}
              alarms = Models::Alarm.filter(conditions).alives.all.each {|alarm|
                alarm.canonical_uuid
              }
              Dcmgr.messaging.submit("resource-alarm-registry.#{resource.host_node.node_id}", 'update_alarms', alarms)
          }
        end

        event.subscribe('hva/instance_turnedon', '#', "#{node.node_id}-resource-alarm") do |args|
          logger.info("event_caught: #{args.inspect}")
          instance_id = args[0]
          @worker_thread.pass {
            resource = Models::Instance[instance_id]
            raise "UnknownResourceID" if resource.nil?

            conditions = {:metric_name =>Dcmgr::Constants::Alarm::RESOURCE_METRICS, :resource_id =>[resource.canonical_uuid]}
            alarms = Models::Alarm.filter(conditions).alives.all.map {|alarm|
              alarm.canonical_uuid
            }
            Dcmgr.messaging.submit("resource-alarm-registry.#{resource.host_node.node_id}", 'update_alarms', alarms)

          }
        end
      end

      terminate_hook do
      end

      def get_alarm(alarm_id)
        alarm = Dcmgr::Models::Alarm[alarm_id] || raise("Unknown alarm ID: #{alarm_id}")
        alarm.to_hash
      end

      def get_alarms(alarm_ids)
        raise ArgumentError unless alarm_ids.is_a?(Array)
        alm_ids = alarm_ids.map {|alarm_id| alarm_id.gsub("alm-", "")}
        alarms = Models::Alarm.filter({:uuid => alm_ids}).all.map { |alarm|
          alarm.to_hash
        }
        alarms
      end

      def get_resource_alarms(resource_ids)
        get_alarms_by_metrics(Dcmgr::Constants::Alarm::RESOURCE_METRICS, resource_ids)
      end

      def get_log_alarms
        get_alarms_by_metrics('log')
      end

      def update_alarm(alarm_id, data)
        raise ArgumentError unless alarm_id.is_a?(String)
        raise ArgumentError unless data.is_a?(Hash)

        logger.info("Update Alarm: #{alarm_id} #{data}")
        alm = Models::Alarm[alarm_id]
        raise "Unknown Alarm ID" if alm.nil?
        alm.state = data["state"]
        alm.state_timestamp = data["state_timestamp"]
        alm.last_evaluated_value = data["last_evaluated_value"]
        alm.last_evaluated_at = data["last_evaluated_at"]
        alm.save
        # do not respond model object.
        nil
      end

      private
      def get_alarms_by_metrics(metric_names=[], resource_ids=[])
        metric_names = [metric_names] if metric_names.is_a?(String)
        resource_ids = [resource_ids] if resource_ids.is_a?(String)

        conditions = {}

        unless metric_names.blank?
          conditions[:metric_name] = metric_names
        end

        unless resource_ids.blank?
          conditions[:resource_id] = resource_ids
        end

        alarms = Models::Alarm.filter(conditions).alives.all.map { |alarm|
          alarm.to_hash
        }
        alarms
      end
    end
  end
end
