# -*- coding: utf-8 -*-

module Dcmgr::NodeModules
  class SGHandler < Isono::NodeModules::Base
    include Dcmgr::Logger
    include Dcmgr::VNet::SGHandler

    initialize_hook do
      app = Isono::Rack::ObjectMethod.new(myinstance)
      myinstance.job.register_endpoint('sg_handler', Isono::Rack.build do
        use Isono::Rack::Sequel
        run proc { |req, res|
          Thread.current[M::BaseNew::LOCK_TABLES_KEY] = {}
          app.call(req, res)
        }
      end)
    end

    def call_packetfilter_service(host_node,method,*args)
      raise "host_node type mismatch. Expected: 'HostNode'. Got: '#{host_node.class}'." unless host_node.is_a?(Dcmgr::Models::HostNode)
      job.run("netfilter-handle.#{host_node.node_id}",method,*args)
    end

    # Override the add and remove functions to support legacy netfilter
    def add_sgs_to_vnic(vnic_id, sg_uuids)
      super(vnic_id, sg_uuids)

      sg_uuids.each { |group_id|
          event.publish("#{group_id}/vnic_joined", :args=>[vnic_id])
          event.publish("#{vnic_id}/joined_group", :args=>[group_id])

          Dcmgr::Models::SecurityGroup[group_id].referencees.each { |ref_sg|
            event.publish("#{ref_sg.canonical_uuid}/referencer_added", :args=>[group_id])
          }
        }
    end

    def remove_sgs_from_vnic(vnic_id, sg_uuids)
      sg_uuids.each { |group_id|
        event.publish("#{group_id}/vnic_left", :args=>[vnic_id])
        event.publish("#{vnic_id}/left_group", :args=>[group_id])

        Dcmgr::Models::SecurityGroup[group_id].referencees.each { |ref_sg|
          event.publish("#{ref_sg.canonical_uuid}/referencer_removed", :args=>[group_id])
        }
      }

      super(vnic_id, sg_uuids)
    end

    def job
      @job ||= Isono::NodeModules::JobChannel.new(node)
    end

    def event
      @event ||= Isono::NodeModules::EventChannel.new(@node)
    end
  end
end
