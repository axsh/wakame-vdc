# -*- coding: utf-8 -*-
require 'isono'

module Dcmgr
  module NodeModules
    class StaCollector < Isono::NodeModules::Base
      include Dcmgr::Logger

      initialize_hook do
        app = Isono::Rack::ObjectMethod.new(myinstance)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        rpc.register_endpoint('sta-collector', Isono::Rack.build do
                                use Isono::Rack::DataStore
                                run proc { |req, res|
                                  Thread.current[Models::BaseNew::LOCK_TABLES_KEY] = {}
                                  app.call(req, res)
                                }
                              end)
      end

      terminate_hook do
      end

      # collect all volume instances on the sta node.
      def get_available_volumes(sta_node_id)
        stnode = Models::StorageNode.alives.filter(:node_id=>sta_node_id).first || raise("Unknown sta node ID: #{sta_node_id}")
        stnode.volumes_dataset.alives.all.delete_if { |volume|
          !volume.ondisk_state?
        }.map { |volume|
          volume.to_hash
        }
      end

      def get_volume(volume_id)
        v = Dcmgr::Models::Volume[volume_id] || raise("Unknown volume ID: #{volume_id}")
        v.to_hash.merge(:volume_device=>v.volume_device.to_hash,
                        :source_backup_object=>(v.backup_object.nil? ? nil : v.backup_object.to_hash()))
      end

      def get_snapshot(snapshot_id)
        vs = Dcmgr::Models::VolumeSnapshot[snapshot_id]
        vs.to_hash
      end

      def get_backup_object(backupobject_id)
        bo = Models::BackupObject[backupobject_id] || raise("Unknown backup object ID: #{backupobject_id}")
        h = bo.to_hash
        h[:backup_storage] = bo.backup_storage.to_hash
        h[:uri] = bo.uri
        h
      end

      def update_volume(volume_id, data)
        v = Dcmgr::Models::Volume[volume_id] || raise("Unknown volume ID: #{volume_id}")
        volume_device_hash = data.delete(:volume_device)
        if volume_device_hash.is_a?(Hash) && v.volume_device
          v.volume_device.set(volume_device_hash).save_changes
        end
        v.set(data).save_changes
        if data[:state].to_s == Const::Volume::STATE_DELETED
          # Volume#destroy do not really delete row.
          # just for chain react destroy hooks in the associated models.
          v.destroy
        end

        # do not respond model object.
        nil
      end

      def update_snapshot(snapshot_id, data)
        vs = Dcmgr::Models::VolumeSnapshot[snapshot_id]
        vs.set(data).save
        if data[:state] == :deleted
          # VolumeSnapshot#destroy do not really delete row.
          # just for chain react destroy hooks in the associated models.
          vs.destroy
        end
        # do not respond model object.
        nil
      end

      def update_backup_object(backupobject_id, data)
        bo = Models::BackupObject[backupobject_id] || raise("Unknown backup object ID: #{backupobject_id}")
        bo.set(data).save_changes
        if data[:state] == :deleted
          # BackupObject#destroy do not really delete row.
          # just for chain react destroy hooks in the associated models.
          bo.destroy
        end
        # do not respond model object.
        nil
      end

      def register_backup_object_transfer(node_id, bo_data)
        bkst = Models::BackupStorage.alives.filter(:node_id=>node_id).first
        raise "Unknown backup storage: #{node_id}" if bkst.nil?

        new_bo_data = bo_data.select{|k, v| Const::BackupObject::CLONED_FIELDS_AT_TRANSFER.member?(k.to_sym) }
        new_bo_data[:state] = Const::BackupObject::STATE_PENDING
        bkst.add_backup_object(new_bo_data).to_hash
      end

      def register_image_transfer(node_id, image_data, bo_data)
        new_image_data = image_data.select{|k, v| Const::Image::CLONED_FIELDS_AT_TRANSFER.member?(k.to_sym) }
        new_image_data[:state] = Const::Image::STATE_PENDING

        new_bo = register_backup_object_transfer(node_id, bo_data)

        new_img = Models::Image.create(new_image_data.merge(:backup_object_id=>new_bo[:uuid]))

        {:backup_object=>new_bo, :image=>new_img.to_hash}
      end

      # Change image state to 'available' if all associating backup
      # objects become 'available'.
      def post_process_backup_image(image_uuid)
        image = Dcmgr::Models::Image[image_uuid] || raise("Unknown image ID: #{image_uuid}")

        if image.volumes.is_a?(Array)
          if image.volumes.all? { |image_volume_item|
              bo = Dcmgr::Models::BackupObject[image_volume_item[:backup_object_id]]
              (bo && bo.state == Const::BackupObject::STATE_AVAILABLE)
            }
          end

          image.state = Const::Image::STATE_AVAILABLE
          image.save_changes
        else
          logger.error("Unexpected type value: #{image.values.class}")
        end

        nil
      end
    end
  end
end
