# -*- coding: utf-8 -*-
module Dcmgr
  module NodeModules
    class InstanceMonitor < Isono::NodeModules::Base
      include Dcmgr::Logger

      initialize_hook do
        @thread_pool = Isono::ThreadPool.new(1, 'InstanceMonitor')
        @monitor = EventMachine::PeriodicTimer.new(5) {
          next if @thread_pool.queue.size > 0
          @thread_pool.pass {
            myinstance.dup.check_instance
          }
        }
      end

      terminate_hook do
        @monitor.cancel
        @thread_pool.shutdown
      end

      # Reset TaskSession per request.
      def task_session
        @task_session ||= begin
                            Task::TaskSession.reset!(:thread)
                            Task::TaskSession.current
                          end
      end

      def check_instance()
        instlst = rpc.request('hva-collector', 'get_instance_monitor_data', manifest.node_id)
        instlst.each { |i|
          running=true
          begin
            task_session.invoke(Dcmgr::Drivers::Hypervisor.driver_class(i[:hypervisor]),
                                :check_instance, [i[:uuid]])
          rescue Exception => e
            running = false
            if i[:status] == 'online'
              logger.error("#{e.class}, #{e.message}")

              rpc.request('hva-collector', 'update_instance', i[:uuid], {:status=>:offline}) { |req|
                req.oneshot = true
              }
              event.publish('hva/fault_instance', :args=>[i[:uuid]])
            end
          else
            if i[:status] != 'online'
              rpc.request('hva-collector', 'update_instance', i[:uuid], {:status=>:online}) { |req|
                req.oneshot = true
              }
            end
          end

          if Dcmgr.conf.enable_instance_state_recovery
            instance_state_recovery(i, running)
          end
        }
      end

      private

      def instance_state_recovery(instance, running)
        if running
          # Nothing to do currently.
        else
          case instance[:state].to_s
          when Const::Instance::STATE_RUNNING
            logger.info("Force state transition for #{instance[:uuid]}: running -> halted")
            rpc.request('hva-collector', 'update_instance', instance[:uuid], {:state=>Const::Instance::STATE_HALTED}) { |req|
              req.oneshot = true
            }
          when Const::Instance::STATE_HALTING
            logger.info("Force state transition for #{instance[:uuid]}: halting -> halted")
            rpc.request('hva-collector', 'update_instance', instance[:uuid], {:state=>Const::Instance::STATE_HALTED}) { |req|
              req.oneshot = true
            }
          when Const::Instance::STATE_SHUTTING_DOWN
            # updated_at attribute requires newer version collector.
            # so waiting feature needs to be disabled if updated_at is
            # missed.
            # TODO: simplify the logic below.
            if (instance[:updated_at] &&
                (Time.now - instance[:updated_at]) > Dcmgr.conf.wait_sec_until_force_terminate_from_shuttingdown) ||
                true
              logger.info("Force state transition for #{instance[:uuid]}: shuttingdown -> terminated")
              job.submit("hva-handle.#{@node.node_id}", "terminate", instance[:uuid], true)
            end
          when Const::Instance::STATE_HALTED
            # Nothing to do.
          end
        end
      end

      def job
        @job ||= Isono::NodeModules::JobChannel.new(@node)
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end
      
      def event
        @event ||= Isono::NodeModules::EventChannel.new(@node)
      end
    end

  end
end
