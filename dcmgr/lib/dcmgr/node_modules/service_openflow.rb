# -*- coding: utf-8 -*-

require 'fileutils'
require 'isono'
require 'ipaddress'
require 'strscan'
require 'trema'
require "trema/dsl/context"
require "trema/shell"
require "trema/util"

module Dcmgr::NodeModules

  class SwitchManagerWrapper
    include Trema::Util

    def do_cleanup
      cleanup_current_session
    end

    def self.list_bridge_sockets
      Dcmgr.conf.dc_networks.values.keep_if { |dcn|
        dcn.bridge_type == 'ovs' and !dcn.name.empty?
      }.map { |dcn|
        dcn.bridge
      }.uniq.map { |bridge|
        "#{Dcmgr.conf.ovs_run_dir}/#{bridge}.controller"
      }
    end
  end

  class ServiceOpenFlow < Isono::NodeModules::Base
    include Dcmgr::Logger
    include Dcmgr::Helpers::NicHelper
    include Dcmgr::VNet::OpenFlow::OpenFlowConstants

    initialize_hook do
      # Trema hack...
      $verbose = true
      ENV['TREMA_HOME'] = Dcmgr.conf.trema_dir
      ENV['TREMA_TMP'] = Dcmgr.conf.trema_tmp

      EH = CustomEventHandler.new
      EH.set_as_handler

      logger.info "trema: pid_directory:'#{Trema.pid}'."

      SwitchManagerWrapper.new.cleanup_current_session

      Dir.glob(File.join(Trema.pid, "*.pid")).each do | each |
        logger.info "trema kill: pid_file:'#{each}'."
        pid = IO.read( each ).chomp.to_i
        system("kill #{pid}") if pid != 0
      end

      rule = {
        :port_status => "OpenFlowController",
        :packet_in => "OpenFlowController",
        :state_notify => "OpenFlowController",
        :vendor => "OpenFlowController"
      }

      bridge_sockets = SwitchManagerWrapper.list_bridge_sockets
      bridge_sockets.each { |path| FileUtils.remove_file(path, true) }

      raise "No OVS bridges defined." if bridge_sockets.empty?

      @switch_manager = Trema::SwitchManager.new( rule, nil, bridge_sockets.last )
      # @switch_manager.command_prefix = "valgrind -q --tool=memcheck --leak-check=yes --trace-children=yes --log-socket=127.0.0.1:12345 "

      logger.info "Calling: '#{@switch_manager.command}'."

      DebugOpenFlow.register_controller(myinstance.openflow_controller)

      myinstance.worker_thread.pass {
        myinstance.prefetch_physical_networks

        system(@switch_manager.command)

        myinstance.openflow_controller.init_trema
        myinstance.openflow_controller.run_immediate!

        # Add the rest of the bridge sockets.
        original_socket = bridge_sockets.pop

        logger.info("using main bridge socket: #{original_socket}")
        next if bridge_sockets.empty?

        sleep(0.2) until File.socket?(original_socket)

        bridge_sockets.each { |path|
          logger.info("adding bridge socket hardlink: #{path}")
          system("ln #{original_socket} #{path}")
        }
      }

      myinstance.event.subscribe('hva/instance_started', '#') do |args|
        myinstance.worker_thread.pass {
          logger.info("refresh on instance_started: #{args.inspect}")
          inst_id = args[0]
          myinstance.add_openflow_by_instance_id(inst_id)
        }
      end

      myinstance.event.subscribe('hva/instance_terminated', '#') do |args|
        myinstance.worker_thread.pass {
          logger.info("refresh on instance_terminated: #{args.inspect}")
          inst_id = args[0]
          myinstance.delete_openflow_by_instance_id(inst_id)
        }
      end

      myinstance.event.subscribe('hva/openflow_updated', '#') do |args|
        myinstance.worker_thread.pass {
          logger.info("refresh on openflow_updated: #{args.inspect}")
          openflow_group_id = args[0]
          myinstance.refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
        }
      end
    end

    terminate_hook do
      myinstance.worker_thread.pass {
        myinstance.openflow_controller.stop_immediate!
        myinstance.openflow_controller.shutdown!
      }

      SwitchManagerWrapper.new.cleanup_current_session
    end

    def add_openflow_by_instance_id(inst_id)
      get_ports_from_instance_id(inst_id).each { |key,port|
        worker_thread.pass { add_instance_now port.datapath.switch, port }
      }
    end

    def delete_openflow_by_instance_id(inst_id)
      get_ports_from_instance_id(inst_id).each { |key,port|
        worker_thread.pass { delete_instance_now port }
      }
    end

    def refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
      raise "UnknownOpenflowGroupID" if openflow_group_id.nil?

      logger.info "Refresh Openflow..."
    end

    #
    #
    #

    def add_eth switch, port
      logger.info "adding eth #{port.port_info.name}."

      return if not port.is_active

      logger.info "port: #{port.port_info.number}"
      logger.info "mac: #{port.port_info.hw_addr.to_s}"
      logger.info "config: #{port.port_info.config}"
      logger.info "state: #{port.port_info.state}"
      logger.info "curr: #{port.port_info.curr}"
      logger.info "advertised: #{port.port_info.advertised}"
      logger.info "supported: #{port.port_info.supported}"
      logger.info "peer: #{port.port_info.peer}"

      port_number = port.port_info.number

      # Add the flows required to keep the network alive before
      # passing the work off to a thread. This ensures that thread
      # timings don't cause it to try initializing any other queued
      # ports before eth is up.
      port.init_eth
      port.datapath.add_flows(port.queued_flows)
      port.queued_flows.clear

      if Dcmgr::VNet::OpenFlow::NetworkPhysical.add_eth_port(port.datapath.datapath_id, port.port_info.number)
        port.datapath.add_flows(Dcmgr::VNet::OpenFlow::NetworkPhysical.physical_flood_flows(port.datapath.datapath_id))
      end

      worker_thread.pass {
        networks_map = get_physical_networks(switch)

        networks_map.each { |network_map|
          network = get_network_from_map(switch, network_map)

          port.networks << network

          port.lock.synchronize {
            return if not port.is_active

            network.add_port(port_number, true)
            network.update

            port.datapath.add_flows(port.queued_flows)
            port.queued_flows.clear

            port.is_inserted = true
          }

          if network.services.has_key?(:metadata) and network.services[:metadata].ip.to_s != switch.bridge_ipv4
            network.services[:metadata].request_mac(switch, port)
          end
        }
      }
    end

    def add_instance switch, port
      worker_thread.pass { add_instance_now switch, port }
    end

    def add_instance_now switch, port
      logger.info "adding instance: port:#{port.port_info.number} vif:#{port.port_info.name}."

      return if port.object_id != switch.ports[port.port_info.number].object_id
      return if port.has_instance

      if !port.is_active
        logger.info "port not active, skipping instance."
        return
      end

      vnic_map = rpc.request('hva-collector', 'get_nic', port.port_info.name)
      logger.debug "vnic_map: #{vnic_map.inspect}"
      raise ArgumentError, "Unknown Nic: #{port.port_info.name}." if vnic_map.nil?
      ip_lease = vnic_map[:address]
      raise ArgumentError, "Unknown IPv4: #{port.port_info.name}." if ip_lease.nil?

      mac_lease = clean_mac(vnic_map[:mac_addr])

      port.ip = ip_lease
      port.mac = mac_lease
      port.has_instance = true

      logger.info "port: #{port.port_info.number}"
      logger.info "mac: #{port.port_info.hw_addr.to_s} <=> #{mac_lease}"
      logger.info "ip: #{ip_lease}"
      logger.info "config: #{port.port_info.config}"
      logger.info "state: #{port.port_info.state}"
      logger.info "curr: #{port.port_info.curr}"
      logger.info "advertised: #{port.port_info.advertised}"
      logger.info "supported: #{port.port_info.supported}"
      logger.info "peer: #{port.port_info.peer}"

      network = get_network_from_map(switch, vnic_map[:network])

      port_number = port.port_info.number
      port.networks << network

      if !network.virtual
        port.init_instance_net(network, mac_lease, ip_lease)
        port.install_arp_antispoof(mac_lease, ip_lease)

        if vnic_map[:network][:dns_server]
          port.install_static_d_transport 17, mac_lease, ip_lease, vnic_map[:network][:dns_server], 53
        end

        if vnic_map[:network][:dhcp_server]
          # Verify that :nw_src is correct in the DHCP service.
          port.install_catch_ip 17, { :dl_src => mac_lease, :nw_dst => vnic_map[:network][:dhcp_server], :tp_dst => 67}
          port.install_catch_ip 17, { :dl_src => mac_lease, :nw_dst => vnic_map[:network][:dhcp_server], :tp_dst => 68}
          port.install_catch_ip 17, { :dl_src => mac_lease, :nw_dst => "255.255.255.255", :tp_dst => 67}
          port.install_catch_ip 17, { :dl_src => mac_lease, :nw_dst => "255.255.255.255", :tp_dst => 68}
        else
          port.install_static_d_transport 17, mac_lease, ip_lease, "0.0.0.0/0", 67
          port.install_static_d_transport 17, mac_lease, ip_lease, "0.0.0.0/0", 68
        end

        add_security_group(port, vnic_map)

        # Testing guest -> *
        port.install_local_icmp          mac_lease, ip_lease
        port.install_local_transport 6,  mac_lease, ip_lease
        port.install_local_transport 17, mac_lease, ip_lease

      else
        port.init_instance_vnet(network, mac_lease, ip_lease)
        port.init_instance_subnet(network, switch.eth_port,  mac_lease, ip_lease) if Dcmgr.conf.enable_subnet
      end

      port.lock.synchronize {
        return if not port.is_active

        if !network.virtual
          network.class.add_eth_port(port.datapath.datapath_id, port.port_info.number)
          port.datapath.add_flows(network.class.physical_flood_flows(port.datapath.datapath_id))
        end

        network.add_port port_number, true
        network.update

        port.datapath.add_flows port.queued_flows
        port.queued_flows.clear

        port.is_inserted = true
      }
    end

    # Always call in the worker thread.
    def delete_instance port
      worker_thread.pass { delete_instance_now port }
    end

    def delete_instance_now port
      logger.info "deleting instance #{port.port_info.name}."

      return if not port.has_instance

      ip_lease = port.ip
      mac_lease = port.mac

      port.ip = nil
      port.mac = nil
      port.has_instance = false

      logger.info "port: #{port.port_info.number}"
      logger.info "mac: #{port.port_info.hw_addr.to_s} <=> #{mac_lease}"
      logger.info "ip: #{ip_lease}"
      logger.info "config: #{port.port_info.config}"
      logger.info "state: #{port.port_info.state}"
      logger.info "curr: #{port.port_info.curr}"
      logger.info "advertised: #{port.port_info.advertised}"
      logger.info "supported: #{port.port_info.supported}"
      logger.info "peer: #{port.port_info.peer}"

      switch = port.datapath.switch
      switch && switch.networks.each { |key,network|
        if network.ports.index(port.port_info.number)
          network.remove_port port.port_info.number
          network.update
        end
      }

      port.lock.synchronize {
        port.is_inserted = false
      }
    end

    def add_tunnel switch, port
      worker_thread.pass { add_tunnel_now switch, port }
    end

    def add_tunnel_now switch, port
      logger.info "Got tunnel port: name:#{port.port_info.name}."

      raise "Tried to add a tunnel with GRE tunnels disabled." if !Dcmgr.conf.enable_gre
      return if not port.is_active

      logger.info "port: #{port.port_info.number}"
      logger.info "mac: #{port.port_info.hw_addr.to_s}"
      logger.info "config: #{port.port_info.config}"
      logger.info "state: #{port.port_info.state}"
      logger.info "curr: #{port.port_info.curr}"
      logger.info "advertised: #{port.port_info.advertised}"
      logger.info "supported: #{port.port_info.supported}"
      logger.info "peer: #{port.port_info.peer}"

      # Note that vnet_id may be different from the actual GRE
      # tunnel id used.
      vnet_id = port.port_info.name[/^t-[a-z0-9]*-([0-9]*)$/, 1].to_i
      raise "GRE tunnel interface name must match 't-[a-z0-9]*-[0-9]*'." if vnet_id.nil? or vnet_id == 0

      network = get_network_from_id(switch, vnet_id)
      port.networks << network
      port.init_gre_tunnel(network)

      port.lock.synchronize {
        return if not port.is_active

        network.add_port(port.port_info.number, false)
        network.update

        port.datapath.add_flows port.queued_flows
        port.queued_flows.clear

        port.is_inserted = true
      }
    end

    def delete_tunnel port
      worker_thread.pass { delete_tunnel_now port }
    end

    def delete_tunnel_now port
      return if not port.has_instance
    end

    # def rebuild_networks
    #   worker_thread.pass { rebuild_networks_now }
    # end

    # def rebuild_networks_now
    #   networks_map = rpc.request('hva-collector', 'get_networks')
    #   raise "Failed to retrieve networks." if networks_map.nil?
    #   # networks.clear

    #   networks_map.each { |network|
    #   }
    # end

    def prefetch_physical_networks
      begin
        networks_map = rpc.request('hva-collector', 'get_networks')
      rescue Isono::NodeModules::RpcChannel::RpcError
      end

      # Sometimes hva-collector doesn't properly reply to the first call.
      if networks_map.nil?
        sleep 5
        networks_map = rpc.request('hva-collector', 'get_networks')
      end

      raise "Failed to retrieve physical networks." if networks_map.nil?

      @networks_map = networks_map.select { |network|
        network[:network_mode] != "l2overlay"
      }
    end

    def get_physical_networks switch
      @networks_map.select { |network_map|
        dcn = Dcmgr.conf.dc_networks[network_map[:dc_network][:name]]
        dcn && dcn.bridge == switch.switch_name
      }
    end

    def get_network_from_id switch, network_id
      return switch.networks[network_id] if switch.networks.has_key?(network_id)

      network_map = rpc.request('hva-collector', 'get_network', network_id)
      raise "Failed to retrieve network #{network_id}." if network_map.nil?

      logger.debug "creating network from: id:#{network_id} map:#{network_map.inspect}."
      create_network network_map
    end

    def get_network_from_map switch, network_map
      if switch.networks.has_key? network_map[:id]
        switch.networks[network_map[:id]]
      else
        logger.debug "creating network from: map:#{network_map.inspect}."
        create_network network_map
      end
    end

    def get_host_node_from_id host_node_id
      host_node_map = rpc.request('hva-collector', 'get_host_node', host_node_id)
      raise "Failed to retrieve host_node #{host_node_id}." if host_node_map.nil?

      logger.debug "got host_node: id:#{host_node_id} map:#{host_node_map.inspect}."
      host_node_map
    end

    def prepare_host_node_vnet host_node_id, network_id
      host_node_vnet_map = rpc.request('hva-collector', 'prepare_host_node_vnet', host_node_id, network_id)
      raise "Failed to prepare host_node_vnet: host_node_id:#{host_node_id} network_id:#{network_id}." if host_node_vnet_map.nil?

      logger.debug "prepared host_node_vnet: host_node_id:#{host_node_id} network_id:#{network_id} map:#{host_node_vnet_map.inspect}."
      host_node_vnet_map
    end

    def create_network network_map
      throw "Network map is invalid: #{network_map.inspect}." if network_map.nil? or network_map[:id] <= 0

      network_id = network_map[:id]

      # find local interface configuration from the DC network name.
      dcn = Dcmgr.conf.dc_networks[network_map[:dc_network][:name]]
      raise "Not found DC network in hva.conf: #{network_map[:dc_network][:name]}" if dcn.nil?
      raise "Bridge type is not capable of this network: name:'#{dcn.name}' type:'#{dcn.bridge_type}'." if dcn.bridge_type != 'ovs'

      switch = @openflow_controller.switches.detect { |key,value| value.switch_name == dcn.bridge }

      throw "No switch found for '#{dcn.bridge}'." if switch.nil?
      throw "Network already created" if switch[1].networks.has_key? network_id and not switch[1].networks[network_id].nil?

      raise "No valid IPv4 network defined." if network_map[:ipv4_network].nil? or not network_map[:ipv4_network] =~ /\.0$/

      if network_map[:network_mode] == "l2overlay"
        network = Dcmgr::VNet::OpenFlow::NetworkVirtual.new(switch[1].datapath, network_id)
      else
        network = Dcmgr::VNet::OpenFlow::NetworkPhysical.new(switch[1].datapath, network_id)
      end

      switch[1].networks[network_id] = network

      network.ipv4_network = IPAddr.new(network_map[:ipv4_network])
      network.prefix = network_map[:prefix]
      network.local_hw = switch[1].local_hw

      logger.debug "Network services: id:#{network_id} services:#{network_map[:network_services].inspect}."

      network_map[:network_services].each { |service|
        network.add_service(switch[1], service)
      }

      if !network.virtual
        logger.info "Creating physical network: id:#{network_id} bridge:#{dcn.bridge} physical:#{dcn.interface}."

        network.add_port(Dcmgr::VNet::OpenFlow::OpenFlowController::OFPP_LOCAL, true)

        if network.services[:gateway].nil? and
            network_map[:ipv4_gw] and !network_map[:ipv4_gw].empty?
          network.add_service(switch[1], {
                                :name => 'gateway',
                                :mac => network.local_hw,
                                :address => network_map[:ipv4_gw]
                              })
        end

        if network.services[:dhcp].nil?
          network.add_service(switch[1], {
                                :name => 'dhcp',
                                :mac_addr => network.local_hw,
                                :address => (network_map[:dhcp_server] and !network_map[:dhcp_server].empty?) ?
                                network_map[:dhcp_server] : (IPAddr.new(network_map[:ipv4_network]) | IPAddr.new("0.0.0.1")).to_s
                              })
        end

        if network.services[:dns].nil? and (network_map[:dns_server] and !network_map[:dns_server].empty?)
          network.add_service(switch[1], {
                                :name => 'dns',
                                :mac_addr => network.local_hw,
                                :address => network_map[:dns_server]
                              })

          if network_map[:domain_name] and !network_map[:domain_name].empty?
            network.services[:dns].domain_name = network_map[:domain_name]
          else
            network.services[:dns].domain_name = 'vdc.local'
          end
        end

        if network_map[:metadata_server] && network_map[:metadata_server_port]
          if network_map[:metadata_server].to_s == switch[1].bridge_ipv4
            network.add_service(switch[1], {
                                  :name => 'metadata',
                                  :port => Dcmgr::VNet::OpenFlow::OpenFlowController::OFPP_LOCAL,
                                  :mac_addr => network.local_hw,
                                  :address => network_map[:metadata_server],
                                  :incoming_port => network_map[:metadata_server_port]
                                })
          else
            network.add_service(switch[1], {
                                  :name => 'metadata',
                                  :port => nil,
                                  :mac_addr => nil,
                                  :address => network_map[:metadata_server],
                                  :incoming_port => network_map[:metadata_server_port]
                                })
          end
        end

        network.update

      else
        logger.info "Creating virtual network: id:#{network_id} bridge:#{dcn.bridge}."

        if network.services[:dns] and network_map[:domain_name] and !network_map[:domain_name].empty?
          network.services[:dns].domain_name = network_map[:domain_name]
        end

        network.install_virtual_network(switch[1].eth_port)

        # Currently just spam everyone with host IPs when a new
        # network is added to a host. This is sufficient for
        # testing, but not production.

        if Dcmgr.conf.enable_subnet
          host_node_map = prepare_host_node_vnet("hn-#{@node.node_id[/^hva\.(.+)$/, 1]}", network_map[:uuid])

          logger.debug "Got host node mac: #{host_node_map.inspect}."
          network.install_mac_subnet(switch[1].eth_port, host_node_map[:broadcast_addr])
        else
          host_node_map = {}
        end

        logger.info "Subscribing to event: 'ovs/network_added/#{network_id}'."

        event.subscribe("ovs/network_added/#{network_id}", '#') do |header, body|
          worker_thread.pass {
            logger.info("Network added event: network_id:#{network_id} header:#{header.inspect} body:#{body.inspect}.")

            if body[:host_id] == @node.node_id.to_s
              logger.info("from the same host...")

            else
              logger.info("Network added event from another host: host_ip:#{body[:host_ip]} send_hosts:#{body[:send_hosts]}.")

              # Limit to once per host:
              if Dcmgr.conf.enable_gre
                network.add_gre_tunnel body[:host_id][/^hva\.([a-z0-9]*)$/, 1], body[:host_ip]
              end

              if Dcmgr.conf.enable_subnet
                network.external_mac_subnet(body[:broadcast_addr])
                network.update
              end

              if body[:send_hosts] == true
                event.publish("ovs/network_added/#{network_id}", :args=>{
                                :network_id => network_map[:id],
                                :send_hosts => false,
                                :host_id => @node.node_id.to_s,
                                :host_ip => switch[1].bridge_ipv4,
                                :broadcast_addr => host_node_map[:broadcast_addr]
                              })
              end
            end
          }
        end

        network.update

        # RPC call to get all the hosts on this network.
        #
        # As a temporary hack, just store the ip addresses in hva_collector?

        event.publish("ovs/network_added/#{network_id}", :args=>{
                        :network_id => network_map[:id],
                        :send_hosts => true,
                        :host_id => @node.node_id,
                        :host_ip => switch[1].bridge_ipv4,
                        :broadcast_addr => host_node_map[:broadcast_addr]
                      })
      end

      network
    end

    def destroy_network network, remove_flows
      if !network.virtual
      else
        event.unsubscribe("ovs/network_added/#{network.id}", '#')
      end
    end

    #
    # Cut-n-paste from ServiceNetfilter
    #

    def add_security_group port, vif_map
      ng_maps = rpc.request('hva-collector', 'get_security_groups_of_vnic', vif_map[:uuid])
      return if ng_maps.nil?

      ng_maps.each {|group|
        group[:rules].each { |rule|
          case rule[:ip_protocol]
          when 'tcp', 'udp'
            if rule[:ip_fport] == rule[:ip_tport]
              port.install_static_transport 6, port.mac, port.ip, rule[:ip_fport], rule[:ip_source]
            elsif rule[:ip_fport] <= 1 and rule[:ip_tport] >= 65535
              port.install_static_transport 6, port.mac, port.ip, 0, rule[:ip_source]
            else
              logger.info "add_security_group: No support for port ranges yet: ip_source:#{rule[:ip_source]} ports:#{rule[:ip_fport]}-#{rule[:ip_tport]}"
            end
          when 'icmp'
            port.install_static_icmp rule[:icmp_type], rule[:icmp_code], port.mac, port.ip, rule[:ip_source]
          end
        }
      }
    end

    def openflow_controller
      @openflow_controller ||= Dcmgr::VNet::OpenFlow::OpenFlowController.new(self)
    end

    def event
      @event ||= Isono::NodeModules::EventChannel.new(@node)
    end

    def rpc
      @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
    end

    def worker_thread
      @worker_thread ||= Isono::ThreadPool.new(1, 'Openflow')
    end

    def get_ports_from_instance_id inst_id
      raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
      inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
      raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

      ports = {}

      openflow_controller.switches.each { |switch_name,switch|
        switch.ports.each { |port_number,port|
          ports[port_number] = port if inst_map[:instance_nics].count { |nic_map| port.port_info.name == nic_map[:uuid] } != 0
        }
      }

      ports
    end

  end

  #
  # Event handler glue for Trema.
  #

  module EventFdConnection
    def initialize connection
      @connection = connection
    end

    def notify_readable
      @connection.notify_readable
    end

    def notify_writable
      @connection.notify_writable
    end

    def unbind
      # EM.next_tick do
      #   # socket is detached from the eventloop, but still open
      #   data = @io.read
      # end
    end
  end


  class CustomEventHandler < Trema::EventHandler
    include Dcmgr::Logger

    @@fd_set = []

    def init_event_handler
      logger.debug "Called CustomEventHandler init_event_handler."
    end

    def finalize_event_handler
      logger.debug "Called CustomEventHandler finalize_event_handler."
    end

    def stop_event_handler
      logger.debug "Called CustomEventHandler stop_event_handler."
      EM.stop
    end

    def run_event_handler_once
      logger.debug "Called CustomEventHandler run_event_handler_once."
    end

    def set_fd_handler fd, connection
      logger.debug "Called CustomEventHandler immediate set_fd_handler, #{fd}."
      raise "CustomEventHandler event handler already registered." if not @@fd_set[ fd ].nil?

      @@fd_set[ fd ] = EM.watch fd, EventFdConnection, connection
    end

    def delete_fd_handler fd
      logger.debug "Called CustomEventHandler delete_fd_handler, #{fd}."
      connection = @@fd_set[ fd ]
      @@fd_set[ fd ] = nil

      connection.detach
    end

    def set_readable fd, state
      # logger.debug "Called CustomEventHandler set_readable, #{fd}."

      if fd < 0
        logger.error "Called set_readable with negative fd: #{fd}, #{state}."
        return
      end

      @@fd_set[ fd ].notify_readable = state
    end

    def set_writable fd, state
      # logger.debug "Called CustomEventHandler set_writable, #{fd}."

      if fd < 0
        logger.error "Called set_writable with negative fd: #{fd}, #{state}."
        return
      end

      @@fd_set[ fd ].notify_writable = state
    end

    def readable fd
      logger.debug "Called CustomEventHandler readable, #{fd}."
    end

    def writable fd
      logger.debug "Called CustomEventHandler writable, #{fd}."
    end

    # Timer event handlers:
    def init_timer
      logger.debug "Called CustomEventHandler init_timer."
    end

    def finalize_timer
      logger.debug "Called CustomEventHandler finalize_timer."
    end

    def add_timer_event_callback timer
      logger.debug "Called CustomEventHandler: first:#{timer.inspect} interval:#{timer.interval} expiration:#{timer.expiration}."

      timer.handle.cancel if not timer.handle.nil?

      # timer.handle = EventMachine::Timer.new(timer.interval) do
      timer.handle = EventMachine::Timer.new(timer.expiration) do
        logger.debug "Calling timer event: first:#{timer.inspect} interval:#{timer.interval} expiration:#{timer.expiration}."
        timer.call
      end
    end

    def add_periodic_event_callback interval, timer
      logger.debug "Called CustomEventHandler: timer:#{timer.inspect} interval:#{interval}."

      timer.handle.cancel if not timer.handle.nil?

      timer.handle = EventMachine::PeriodicTimer.new(interval) do
        # logger.debug "Calling periodic timer event: timer:#{timer.inspect} interval:#{interval}."
        timer.call
      end
    end

    def delete_timer_event timer
      logger.debug "Called CustomEventHandler: timer:#{timer.inspect}."

      timer.handle.cancel if not timer.handle.nil?
      timer.handle = nil
    end

    def execute_timer_events
      logger.debug "Called CustomEventHandler execute_timer_events."
    end

  end

end
