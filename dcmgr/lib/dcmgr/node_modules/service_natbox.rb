# -*- coding: utf-8 -*-

require 'fileutils'
require 'isono'
require 'ipaddress'

module Dcmgr::NodeModules

  class ServiceNatbox < Isono::NodeModules::Base
    include Dcmgr::Logger

    initialize_hook do
      logger.info "Initializing Natbox."

      myinstance.worker_thread.pass {
        logger.info "Initializing Natbox worker_thread."

        myinstance.restore

        myinstance.event.subscribe("vnet/network_route/created", '#') { |header, body|
          myinstance.worker_thread.pass {
            myinstance.network_route_created(header, body)
          }
        }
        myinstance.event.subscribe("vnet/network_route/deleted", '#') { |header, body|
          myinstance.worker_thread.pass {
            myinstance.network_route_deleted(header, body)
          }
        }
      }
    end

    terminate_hook do
      logger.info "Terminating Natbox."
    end

    def network_route_created(header, body)
      body.each do |network_route_id|
        network_route = get_network_route(network_route_id, inner_dc_network_name)
        add_nat(network_route[:outer_ipv4], network_route[:inner_ipv4]) if network_route
      end
    end

    def network_route_deleted(header, body)
      body.each do |network_route_id|
        network_route = get_network_route(network_route_id, inner_dc_network_name)
        remove_nat(network_route[:outer_ipv4], network_route[:inner_ipv4]) if network_route
      end
    end

    def restore
      remove_all_nat
      # TODO paginate
      rpc.request('natbox-collector', 'get_alive_network_routes', inner_dc_network_name).each do |network_route|
        add_nat(network_route[:outer_ipv4], network_route[:inner_ipv4])
      end
    end

    def event
      raise "Only ServiceOpenflow::worker_threads can access this event channel." unless worker_thread.member_thread?
      @event ||= Isono::NodeModules::EventChannel.new(@node)
    end

    def rpc
      @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
    end

    def worker_thread
      @worker_thread ||= Isono::ThreadPool.new(1, 'Natbox')
    end

    private
    def ovs_ofctl
      return @ovs_ofctl if @ovs_ofctl
      @ovs_ofctl = Dcmgr::VNet::OpenFlow::OvsOfctl.new.tap do |ovs_ofctl|
        ovs_ofctl.switch_name = Dcmgr.conf.outside_dc_network.bridge
      end
    end

    def create_flow(match = {}, actions = {})
      Dcmgr::VNet::OpenFlow::Flow.new(Dcmgr.conf.ovs_flow_table, Dcmgr.conf.ovs_flow_priority,
                 { :ip => nil }.merge(match), actions)
    end

    def add_nat(outer_ipv4, inner_ipv4)
      ovs_ofctl.add_flows_from_list([
        create_flow({:nw_dst => outer_ipv4 },
                    {:mod_nw_dst => inner_ipv4, :normal => nil }),
        create_flow({:nw_src => inner_ipv4 },
                    {:mod_nw_src => outer_ipv4, :normal => nil }),
      ])
    end

    def remove_nat(outer_ipv4, inner_ipv4)
      ovs_ofctl.del_flows_from_list([
        create_flow({:nw_dst => outer_ipv4 }),
        create_flow({:nw_src => inner_ipv4 }),
      ])
    end

    def remove_all_nat
      ovs_ofctl.del_flows_from_list([create_flow])
    end

    def get_network_route(id, dc_network_name)
      rpc.request('natbox-collector', 'get_network_route', id, dc_network_name)
    end

    def inner_dc_network_name
      Dcmgr.conf.inside_dc_network.name
    end
  end

end
